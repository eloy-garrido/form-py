#!/usr/bin/env python3
"""
MCP Server para procesamiento de plantillas Word - Versi√≥n que funciona con Claude
Reemplaza campos {{campo}} en documentos Word con datos proporcionados
"""

import os
import re
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from docx import Document
from mcp.server.fastmcp import FastMCP

# Configuraci√≥n de paths
BASE_DIR = Path(__file__).parent
TEMPLATE_PATH = BASE_DIR / "plantilla_formulario.docx"
OUTPUT_DIR = BASE_DIR / "form-generados"

# Crear servidor MCP
mcp = FastMCP("Word Form Processor - Claude Compatible")


def find_template_fields(doc_path: Path) -> List[str]:
    """
    Extrae todos los campos {{campo}} de un documento Word de manera eficiente
    """
    try:
        doc = Document(doc_path)
        fields = set()
        
        def extract_fields_from_text(text: str):
            """Extrae campos de un texto dado"""
            matches = re.findall(r'\{\{([^}]+)\}\}', text)
            fields.update(matches)
        
        # Buscar en p√°rrafos
        for paragraph in doc.paragraphs:
            extract_fields_from_text(paragraph.text)
        
        # Buscar en tablas
        for table in doc.tables:
            for row in table.rows:
                for cell in row.cells:
                    for paragraph in cell.paragraphs:
                        extract_fields_from_text(paragraph.text)
        
        # Buscar en headers y footers
        for section in doc.sections:
            if section.header:
                for paragraph in section.header.paragraphs:
                    extract_fields_from_text(paragraph.text)
            
            if section.footer:
                for paragraph in section.footer.paragraphs:
                    extract_fields_from_text(paragraph.text)
        
        return sorted(list(fields))
    
    except Exception as e:
        raise ValueError(f"Error al leer la plantilla: {str(e)}")


def replace_fields_in_document(doc: Document, fields_data: Dict[str, str]) -> int:
    """
    Reemplaza todos los campos en el documento de manera eficiente
    Retorna el n√∫mero de reemplazos realizados
    """
    replacements_count = 0
    print(f"[DEBUG] replace_fields_in_document - Iniciando reemplazo con datos: {fields_data}") # DEBUG
    def replace_in_runs(paragraph, fields_data):
        """Reemplaza campos en un p√°rrafo de manera eficiente"""
        count = 0
        for run in paragraph.runs:
            original_text = run.text
            new_text = original_text
            
            # Realizar todos los reemplazos en una sola pasada
            for field, value in fields_data.items():
                pattern = f"{{{{{field}}}}}"
                if pattern in new_text:
                    print(f"[DEBUG] replace_in_runs - Encontrado patr√≥n '{pattern}' en el texto. Reemplazando con '{value}'.") # DEBUG
                    occurrences = new_text.count(pattern)
                    new_text = new_text.replace(pattern, str(value))
                    count += occurrences
            
            if original_text != new_text:
                print(f"[DEBUG] replace_in_runs - Texto original del run: '{original_text}', Texto nuevo: '{new_text}'") # DEBUG
            run.text = new_text
        return count
    
    # Reemplazar en p√°rrafos principales
    for paragraph in doc.paragraphs:
        replacements_count += replace_in_runs(paragraph, fields_data)
    
    # Reemplazar en tablas
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                for paragraph in cell.paragraphs:
                    replacements_count += replace_in_runs(paragraph, fields_data)
    
    # Reemplazar en headers y footers
    for section in doc.sections:
        if section.header:
            for paragraph in section.header.paragraphs:
                replacements_count += replace_in_runs(paragraph, fields_data)
        
        if section.footer:
            for paragraph in section.footer.paragraphs:
                replacements_count += replace_in_runs(paragraph, fields_data)
    
    print(f"[DEBUG] replace_fields_in_document - Total de reemplazos realizados: {replacements_count}") # DEBUG
    return replacements_count


@mcp.tool()
def list_template_fields() -> str:
    """
    Lista todos los campos {{campo}} disponibles en la plantilla
    """
    if not TEMPLATE_PATH.exists():
        return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
    
    try:
        fields = find_template_fields(TEMPLATE_PATH)
        
        if not fields:
            return "‚ÑπÔ∏è No se encontraron campos {{}} en la plantilla"
        
        result = f"üìù Campos encontrados en la plantilla ({len(fields)}):\n\n"
        for i, field in enumerate(fields, 1):
            result += f"{i}. {{{{{field}}}}}\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def preview_replacements(fields_data: str) -> str:
    """
    Previsualiza qu√© campos se reemplazar√≠an sin generar el archivo
    
    Args:
        fields_data: JSON string con los datos de los campos
                    Ejemplo: '{"nombre_estudiante": "Juan P√©rez", "rut_estudiante": "12345678-9"}'
    """
    print(f"[DEBUG] preview_replacements - fields_data recibido: {fields_data}")  # DEBUG
    try:
        data = json.loads(fields_data)
        print(f"[DEBUG] preview_replacements - datos parseados: {data}")  # DEBUG
    try:
        data = json.loads(fields_data)
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Obtener campos de la plantilla
        template_fields = find_template_fields(TEMPLATE_PATH)
        
        result = "üîç Vista previa de reemplazos:\n\n"
        
        # Mostrar campos que se reemplazar√≠an
        replaced_fields = []
        for field in template_fields:
            if field in data:
                result += f"‚úÖ {{{{{field}}}}} ‚Üí {data[field]}\n"
                replaced_fields.append(field)
            else:
                result += f"‚ö†Ô∏è {{{{{field}}}}} ‚Üí [SIN VALOR]\n"
        
        # Mostrar campos extra en los datos
        extra_fields = set(data.keys()) - set(template_fields)
        if extra_fields:
            result += f"\nüìù Campos en los datos que no est√°n en la plantilla:\n"
            for field in extra_fields:
                result += f"‚ÑπÔ∏è {field}: {data[field]}\n"
        
        result += f"\nüìä Resumen: {len(replaced_fields)}/{len(template_fields)} campos se reemplazar√≠an"
        
        print(f"[DEBUG] preview_replacements - resultado: {result}")  # DEBUG
        return result
    
    except json.JSONDecodeError:
        return "‚ùå Error: Los datos deben estar en formato JSON v√°lido"
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def generate_document(fields_data: str, filename_prefix: str = "") -> str:
    """
    Genera un nuevo documento Word reemplazando los campos con los datos proporcionados
    
    Args:
        fields_data: JSON string con los datos de los campos
                    Ejemplo: '{"nombre_estudiante": "Juan P√©rez", "rut_estudiante": "12345678-9"}'
        filename_prefix: Prefijo opcional para el nombre del archivo (default: "")
    """
    print(f"[DEBUG] generate_document - fields_data recibido: {fields_data}")  # DEBUG
    print(f"[DEBUG] generate_document - filename_prefix: {filename_prefix}")  # DEBUG
    try:
        data = json.loads(fields_data)
        print(f"[DEBUG] generate_document - datos parseados: {data}")  # DEBUG
    try:
        data = json.loads(fields_data)
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Asegurar que existe el directorio de salida
        OUTPUT_DIR.mkdir(exist_ok=True)
        
        # Cargar documento
        doc = Document(TEMPLATE_PATH)
        
        # Realizar reemplazos
        replacements_count = replace_fields_in_document(doc, data)
        
        # Generar nombre de archivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if filename_prefix:
            # Asegurar que no hay guion bajo duplicado
            if filename_prefix.endswith('_'):
                filename = f"{filename_prefix}{timestamp}.docx"
            else:
                filename = f"{filename_prefix}_{timestamp}.docx"
        else:
            # Intentar usar nombre_estudiante como prefijo si est√° disponible
            name = data.get('nombre_estudiante', data.get('nombre', ''))
            if name:
                # Limpiar nombre para uso en archivo
                clean_name = re.sub(r'[^\w\s-]', '', name).strip()
                clean_name = re.sub(r'[-\s]+', '_', clean_name)
                filename = f"{clean_name}_{timestamp}.docx"
            else:
                filename = f"documento_{timestamp}.docx"
        
        # Guardar archivo
        output_path = OUTPUT_DIR / filename
        doc.save(output_path)
        
        result = f"‚úÖ Documento generado exitosamente!\n\n"
        result += f"üìÅ Archivo: {filename}\n"
        result += f"üìç Ubicaci√≥n: {output_path}\n"
        result += f"üîÑ Reemplazos realizados: {replacements_count}\n"
        result += f"üìä Campos procesados: {len(data)}\n\n"
        result += f"üéØ Datos procesados:\n"
        for key, value in data.items():
            result += f"   ‚Ä¢ {key}: {value}\n"
        
        return result
    
    except json.JSONDecodeError:
        return "‚ùå Error: Los datos deben estar en formato JSON v√°lido"
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def create_pascale_document() -> str:
    """
    Funci√≥n especializada para crear el documento de Pascale con datos predefinidos
    """
    try:
        # Datos predefinidos de Pascale
        data = {
            "nombre_estudiante": "Pascale Cataleya Figueroa Olgu√≠n",
            "rut_estudiante": "26.292.242-1",
            "nacimiento_estudiante": "27-05-2018",
            "edad_estudiante_a√±os_meses": "7 a√±os 0 meses",
            "curso": "1¬∞A"
        }
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Asegurar que existe el directorio de salida
        OUTPUT_DIR.mkdir(exist_ok=True)
        
        # Cargar documento
        doc = Document(TEMPLATE_PATH)
        
        # Realizar reemplazos
        replacements_count = replace_fields_in_document(doc, data)
        
        # Generar nombre de archivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"Informe_Pascale_{timestamp}.docx"
        
        # Guardar archivo
        output_path = OUTPUT_DIR / filename
        doc.save(output_path)
        
        result = f"‚úÖ Documento de Pascale generado exitosamente!\n\n"
        result += f"üìÅ Archivo: {filename}\n"
        result += f"üìç Ubicaci√≥n: {output_path}\n"
        result += f"üîÑ Reemplazos realizados: {replacements_count}\n"
        result += f"üìä Campos procesados: {len(data)}\n\n"
        result += f"üéØ Datos utilizados:\n"
        for key, value in data.items():
            result += f"   ‚Ä¢ {key}: {value}\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def debug_info() -> str:
    """
    Informaci√≥n de debug del sistema
    """
    result = "üîß Informaci√≥n de Debug\n\n"
    result += f"üìÅ Directorio base: {BASE_DIR}\n"
    result += f"üìÑ Plantilla: {TEMPLATE_PATH}\n"
    result += f"‚úÖ Plantilla existe: {TEMPLATE_PATH.exists()}\n"
    result += f"üìÅ Directorio salida: {OUTPUT_DIR}\n"
    result += f"‚úÖ Directorio salida existe: {OUTPUT_DIR.exists()}\n\n"
    
    if TEMPLATE_PATH.exists():
        try:
            fields = find_template_fields(TEMPLATE_PATH)
            result += f"üîç Campos en plantilla ({len(fields)}):\n"
            for field in fields:
                result += f"   ‚Ä¢ {{{{{field}}}}}\n"
        except Exception as e:
            result += f"‚ùå Error leyendo plantilla: {e}\n"
    
    result += f"\nüêç Versi√≥n Python: {sys.version.split()[0]}\n"
    result += f"üì¶ Directorio actual: {os.getcwd()}\n"
    
    # Verificar dependencias
    try:
        import docx
        result += f"‚úÖ python-docx: Disponible\n"
    except ImportError:
        result += f"‚ùå python-docx: No disponible\n"
    
    try:
        import mcp
        result += f"‚úÖ mcp: Disponible\n"
    except ImportError:
        result += f"‚ùå mcp: No disponible\n"
    
    return result


@mcp.tool()
def list_generated_documents() -> str:
    """
    Lista todos los documentos generados en el directorio de salida
    """
    try:
        if not OUTPUT_DIR.exists():
            return "üìÅ El directorio de documentos generados a√∫n no existe"
        
        # Buscar archivos .docx
        docx_files = list(OUTPUT_DIR.glob("*.docx"))
        
        if not docx_files:
            return "üìÅ No hay documentos generados a√∫n"
        
        # Ordenar por fecha de modificaci√≥n (m√°s reciente primero)
        docx_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        result = f"üìã Documentos generados ({len(docx_files)}):\n\n"
        
        for i, file_path in enumerate(docx_files, 1):
            # Obtener informaci√≥n del archivo
            stat = file_path.stat()
            size_mb = stat.st_size / (1024 * 1024)
            modified_time = datetime.fromtimestamp(stat.st_mtime)
            
            result += f"{i}. {file_path.name}\n"
            result += f"   üìÖ Modificado: {modified_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            result += f"   üìä Tama√±o: {size_mb:.2f} MB\n\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


if __name__ == "__main__":
    # Ejecutar el servidor
    mcp.run()
