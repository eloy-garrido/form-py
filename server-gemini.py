#!/usr/bin/env python3
"""
MCP Server para procesamiento de plantillas Word - Versi√≥n que funciona con Claude
Reemplaza campos {{campo}} en documentos Word con datos proporcionados
"""

import os
import re
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

from docx import Document
# Es buena pr√°ctica importar el tipo Document directamente desde docx
from docx.document import Document as DocxDocument
from docx.table import Table as DocxTable
from docx.text.paragraph import Paragraph as DocxParagraph
from mcp.server.fastmcp import FastMCP

# Configuraci√≥n de paths
BASE_DIR = Path(__file__).parent
TEMPLATE_PATH = BASE_DIR / "plantilla_formulario.docx"
OUTPUT_DIR = BASE_DIR / "form-generados"

# Crear servidor MCP
mcp = FastMCP("Word Form Processor - Claude Compatible")


def find_template_fields(doc_path: Path) -> List[str]:
    """
    Extrae todos los campos {{campo}} de un documento Word de manera eficiente
    """
    try:
        doc = Document(doc_path)
        fields = set()
        
        def extract_fields_from_text(text: str):
            """Extrae campos de un texto dado"""
            matches = re.findall(r'\{\{([^}]+)\}\}', text)
            fields.update(matches)
        
        # Buscar en p√°rrafos principales
        for paragraph in doc.paragraphs:
            extract_fields_from_text(paragraph.text)
        
        # Buscar en tablas
        for table in doc.tables:
            for row in table.rows:
                for cell in row.cells:
                    # Las celdas pueden contener m√∫ltiples p√°rrafos
                    for paragraph in cell.paragraphs:
                        extract_fields_from_text(paragraph.text)
        
        # Buscar en headers y footers
        for section in doc.sections:
            # Header principal (primera p√°gina)
            if section.header:
                for paragraph in section.header.paragraphs:
                    extract_fields_from_text(paragraph.text)
            
            # Header para p√°ginas impares/pares (si se usan)
            if section.even_page_header:
                for paragraph in section.even_page_header.paragraphs:
                    extract_fields_from_text(paragraph.text)

            if section.first_page_header:
                for paragraph in section.first_page_header.paragraphs:
                    extract_fields_from_text(paragraph.text)
            
            # Footer principal (primera p√°gina)
            if section.footer:
                for paragraph in section.footer.paragraphs:
                    extract_fields_from_text(paragraph.text)

            # Footer para p√°ginas impares/pares (si se usan)
            if section.even_page_footer:
                for paragraph in section.even_page_footer.paragraphs:
                    extract_fields_from_text(paragraph.text)

            if section.first_page_footer:
                for paragraph in section.first_page_footer.paragraphs:
                    extract_fields_from_text(paragraph.text)
        
        return sorted(list(fields))
    
    except Exception as e:
        raise ValueError(f"Error al leer la plantilla: {str(e)}")


def replace_fields_in_document(doc: DocxDocument, fields_data: Dict[str, str]) -> int:
    """
    Reemplaza todos los campos en el documento de manera eficiente,
    manejando campos que pueden estar divididos en m√∫ltiples 'runs'.
    Retorna el n√∫mero de reemplazos realizados.
    """
    replacements_count = 0
    
    def _replace_in_paragraph_or_cell(paragraph: DocxParagraph, data_map: Dict[str, str]):
        nonlocal replacements_count
        original_text = paragraph.text
        new_text = original_text
        current_paragraph_replacements = 0

        # Iterar sobre los datos para reemplazar todos los campos en este texto
        for field, value in data_map.items():
            # Usar re.escape para el nombre del campo, por si contiene caracteres especiales de regex
            pattern = r'\{\{' + re.escape(field) + r'\}\}'
            
            # Contar las ocurrencias antes de reemplazar
            matches = list(re.finditer(pattern, new_text))
            if matches:
                new_text = re.sub(pattern, str(value), new_text)
                current_paragraph_replacements += len(matches)
        
        # Si se realiz√≥ al menos un reemplazo, actualiza el p√°rrafo
        # Asignar a paragraph.text autom√°ticamente gestiona los 'runs' internos.
        if current_paragraph_replacements > 0:
            paragraph.text = new_text
            replacements_count += current_paragraph_replacements

    # Reemplazar en p√°rrafos principales
    for paragraph in doc.paragraphs:
        _replace_in_paragraph_or_cell(paragraph, fields_data)
    
    # Reemplazar en tablas
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                for paragraph in cell.paragraphs:
                    _replace_in_paragraph_or_cell(paragraph, fields_data)
    
    # Reemplazar en headers y footers para todas las secciones
    for section in doc.sections:
        if section.header:
            for paragraph in section.header.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)
        
        if section.even_page_header:
            for paragraph in section.even_page_header.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)

        if section.first_page_header:
            for paragraph in section.first_page_header.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)
        
        if section.footer:
            for paragraph in section.footer.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)

        if section.even_page_footer:
            for paragraph in section.even_page_footer.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)

        if section.first_page_footer:
            for paragraph in section.first_page_footer.paragraphs:
                _replace_in_paragraph_or_cell(paragraph, fields_data)
    
    return replacements_count


@mcp.tool()
def list_template_fields() -> str:
    """
    Lista todos los campos {{campo}} disponibles en la plantilla
    """
    if not TEMPLATE_PATH.exists():
        return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
    
    try:
        fields = find_template_fields(TEMPLATE_PATH)
        
        if not fields:
            return "‚ÑπÔ∏è No se encontraron campos {{}} en la plantilla"
        
        result = f"üìù Campos encontrados en la plantilla ({len(fields)}):\n\n"
        for i, field in enumerate(fields, 1):
            result += f"{i}. {{{{{field}}}}}\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def preview_replacements(fields_data: str) -> str:
    """
    Previsualiza qu√© campos se reemplazar√≠an sin generar el archivo
    
    Args:
        fields_data: JSON string con los datos de los campos
                    Ejemplo: '{"nombre_estudiante": "Juan P√©rez", "rut_estudiante": "12345678-9"}'
    """
    try:
        data = json.loads(fields_data)
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Obtener campos de la plantilla
        template_fields = find_template_fields(TEMPLATE_PATH)
        
        result = "üîç Vista previa de reemplazos:\n\n"
        
        # Mostrar campos que se reemplazar√≠an
        replaced_fields = []
        for field in template_fields:
            if field in data:
                result += f"‚úÖ {{{{{field}}}}} ‚Üí '{data[field]}'\n" # A√±adidas comillas para claridad
                replaced_fields.append(field)
            else:
                result += f"‚ö†Ô∏è {{{{{field}}}}} ‚Üí [SIN VALOR]\n"
        
        # Mostrar campos extra en los datos
        extra_fields = set(data.keys()) - set(template_fields)
        if extra_fields:
            result += f"\nüìù Campos en los datos que no est√°n en la plantilla:\n"
            for field in extra_fields:
                result += f"‚ÑπÔ∏è {field}: '{data[field]}'\n"
        
        result += f"\nüìä Resumen: {len(replaced_fields)}/{len(template_fields)} campos se reemplazar√≠an"
        
        return result
    
    except json.JSONDecodeError:
        return "‚ùå Error: Los datos deben estar en formato JSON v√°lido. Aseg√∫rate de que es una cadena JSON."
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def generate_document(fields_data: str, filename_prefix: str = "") -> str:
    """
    Genera un nuevo documento Word reemplazando los campos con los datos proporcionados
    
    Args:
        fields_data: JSON string con los datos de los campos
                    Ejemplo: '{"nombre_estudiante": "Juan P√©rez", "rut_estudiante": "12345678-9"}'
        filename_prefix: Prefijo opcional para el nombre del archivo (default: "")
    """
    try:
        data = json.loads(fields_data)
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Asegurar que existe el directorio de salida
        OUTPUT_DIR.mkdir(exist_ok=True)
        
        # Cargar documento
        doc = Document(TEMPLATE_PATH)
        
        # Realizar reemplazos
        replacements_count = replace_fields_in_document(doc, data)
        
        # Generar nombre de archivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if filename_prefix:
            # Asegurar que no hay guion bajo duplicado y limpiar el prefijo
            clean_prefix = re.sub(r'[^\w\s-]', '', filename_prefix).strip()
            clean_prefix = re.sub(r'[-\s]+', '_', clean_prefix)
            if clean_prefix: # Evitar doble guion bajo si el prefijo est√° vac√≠o
                filename = f"{clean_prefix}_{timestamp}.docx"
            else:
                filename = f"documento_{timestamp}.docx"
        else:
            # Intentar usar nombre_estudiante como prefijo si est√° disponible
            name = data.get('nombre_estudiante', data.get('nombre', ''))
            if name:
                # Limpiar nombre para uso en archivo
                clean_name = re.sub(r'[^\w\s-]', '', name).strip()
                clean_name = re.sub(r'[-\s]+', '_', clean_name)
                filename = f"{clean_name}_{timestamp}.docx"
            else:
                filename = f"documento_{timestamp}.docx"
        
        # Guardar archivo
        output_path = OUTPUT_DIR / filename
        doc.save(output_path)
        
        result = f"‚úÖ Documento generado exitosamente!\n\n"
        result += f"üìÅ Archivo: {filename}\n"
        result += f"üìç Ubicaci√≥n: {output_path}\n"
        result += f"üîÑ Reemplazos realizados: {replacements_count}\n"
        result += f"üìä Campos procesados: {len(data)}\n\n"
        result += f"üéØ Datos procesados:\n"
        # Limitar la longitud de los valores para no saturar el output si son muy largos
        for key, value in data.items():
            display_value = str(value)
            if len(display_value) > 100:
                display_value = display_value[:97] + "..."
            result += f"   ‚Ä¢ {key}: '{display_value}'\n"
        
        return result
    
    except json.JSONDecodeError:
        return "‚ùå Error: Los datos deben estar en formato JSON v√°lido. Aseg√∫rate de que es una cadena JSON."
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def create_pascale_document() -> str:
    """
    Funci√≥n especializada para crear el documento de Pascale con datos predefinidos
    """
    try:
        # Datos predefinidos de Pascale
        data = {
            "nombre_estudiante": "Pascale Cataleya Figueroa Olgu√≠n",
            "rut_estudiante": "26.292.242-1",
            "nacimiento_estudiante": "27-05-2018",
            "edad_estudiante_a√±os_meses": "7 a√±os 0 meses",
            "curso": "1¬∞A"
        }
        
        if not TEMPLATE_PATH.exists():
            return f"‚ùå Error: No se encontr√≥ la plantilla en {TEMPLATE_PATH}"
        
        # Asegurar que existe el directorio de salida
        OUTPUT_DIR.mkdir(exist_ok=True)
        
        # Cargar documento
        doc = Document(TEMPLATE_PATH)
        
        # Realizar reemplazos
        replacements_count = replace_fields_in_document(doc, data)
        
        # Generar nombre de archivo
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"Informe_Pascale_{timestamp}.docx"
        
        # Guardar archivo
        output_path = OUTPUT_DIR / filename
        doc.save(output_path)
        
        result = f"‚úÖ Documento de Pascale generado exitosamente!\n\n"
        result += f"üìÅ Archivo: {filename}\n"
        result += f"üìç Ubicaci√≥n: {output_path}\n"
        result += f"üîÑ Reemplazos realizados: {replacements_count}\n"
        result += f"üìä Campos procesados: {len(data)}\n\n"
        result += f"üéØ Datos utilizados:\n"
        for key, value in data.items():
            result += f"   ‚Ä¢ {key}: '{value}'\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


@mcp.tool()
def debug_info() -> str:
    """
    Informaci√≥n de debug del sistema
    """
    result = "üîß Informaci√≥n de Debug\n\n"
    result += f"üìÅ Directorio base: {BASE_DIR}\n"
    result += f"üìÑ Plantilla: {TEMPLATE_PATH}\n"
    result += f"‚úÖ Plantilla existe: {TEMPLATE_PATH.exists()}\n"
    if TEMPLATE_PATH.exists():
        try:
            # Intentar abrir la plantilla para ver si es un archivo docx v√°lido
            Document(TEMPLATE_PATH)
            result += "‚úÖ Plantilla es un archivo DOCX v√°lido\n"
        except Exception as e:
            result += f"‚ùå Error al abrir plantilla DOCX: {e}\n"

    result += f"üìÅ Directorio salida: {OUTPUT_DIR}\n"
    result += f"‚úÖ Directorio salida existe: {OUTPUT_DIR.exists()}\n\n"
    
    if TEMPLATE_PATH.exists():
        try:
            fields = find_template_fields(TEMPLATE_PATH)
            result += f"üîç Campos en plantilla ({len(fields)}):\n"
            if fields:
                for field in fields:
                    result += f"   ‚Ä¢ {{{{{field}}}}}\n"
            else:
                result += "   (Ninguno encontrado)\n"
        except Exception as e:
            result += f"‚ùå Error leyendo campos de plantilla: {e}\n"
    
    result += f"\nüêç Versi√≥n Python: {sys.version.split()[0]}\n"
    result += f"üì¶ Directorio actual: {os.getcwd()}\n"
    
    # Verificar dependencias
    try:
        import docx
        result += f"‚úÖ python-docx: Disponible (Versi√≥n: {docx.__version__ if hasattr(docx, '__version__') else 'Desconocida'})\n"
    except ImportError:
        result += f"‚ùå python-docx: No disponible\n"
    
    try:
        import mcp
        result += f"‚úÖ mcp: Disponible (Versi√≥n: {mcp.__version__ if hasattr(mcp, '__version__') else 'Desconocida'})\n"
    except ImportError:
        result += f"‚ùå mcp: No disponible\n"
    
    return result


@mcp.tool()
def list_generated_documents() -> str:
    """
    Lista todos los documentos generados en el directorio de salida
    """
    try:
        if not OUTPUT_DIR.exists():
            return "üìÅ El directorio de documentos generados a√∫n no existe"
        
        # Buscar archivos .docx
        docx_files = list(OUTPUT_DIR.glob("*.docx"))
        
        if not docx_files:
            return "üìÅ No hay documentos generados a√∫n"
        
        # Ordenar por fecha de modificaci√≥n (m√°s reciente primero)
        docx_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        result = f"üìã Documentos generados ({len(docx_files)}):\n\n"
        
        for i, file_path in enumerate(docx_files, 1):
            # Obtener informaci√≥n del archivo
            stat = file_path.stat()
            size_mb = stat.st_size / (1024 * 1024)
            modified_time = datetime.fromtimestamp(stat.st_mtime)
            
            result += f"{i}. {file_path.name}\n"
            result += f"   üìÖ Modificado: {modified_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
            result += f"   üìä Tama√±o: {size_mb:.2f} MB\n\n"
        
        return result
    
    except Exception as e:
        return f"‚ùå Error: {str(e)}"


if __name__ == "__main__":
    # Aseg√∫rate de que el directorio de salida exista al iniciar el servidor
    # o al menos antes de la primera generaci√≥n.
    # OUTPUT_DIR.mkdir(exist_ok=True) # Ya se hace en generate_document y create_pascale_document

    # Ejecutar el servidor
    mcp.run()